common = import_da('common')
dbEmulator = import_da('DbEmulator')
import logging

import time
import uuid
import copy
import pprint

#stores all original requests indexed by unique id
requests = {}
versionMap = {}
cachedUpdates = {}

#possible status of tentative updates
ongoing = 1
success = 2
failure = 3

class Version():
	def __init__(self,rts,wts):
		self.rts = rts
		self.wts = wts
		self.pendingMightRead = []

class Coordinator(process):
	def setup(configFile:str,coIdMap:dict,workerResCoMap:dict,dbId:dbEmulator.DbEmulator):
		self.configHashMap={}
		self.workerIndex=0

	def run():
		#output("hello SubCo!")
		self.configHashMap = common.readConfigFile(configFile)
		#output("Hello Im coordinator!!!")
		await(False)

	def getCachedUpdates(obj,req):
		cache = {}
		readAttr = common.defReadAttr(obj,req) + common.mightReadAttr(obj,req)
		if obj in cachedUpdates:
			updates = cachedUpdates[obj]
			for item in updates:
				if item['attrName'] in readAttr:
					cache['attrName'] = item['attrName']
					cache['attrValue'] = item['attrValue']
		return cache

	def latestVersionBefore(obj, attr, ts):
		v = None
		if (obj, attr) in versionMap:
			versionList = versionMap[(obj, attr)]
			#sort version list based on timestamp
			sortedVersionList = sorted(versionList, key=lambda x: x.wts)
			prev = None
			for v in sortedVersionList:
				if(v.wts > ts):
					break
				prev = v
			
			v = prev
		
		if(not v):
			v = Version(0, 0)
			if (obj, attr) in versionMap:
				versionMap[(obj, attr)].append(v)
			else:
				versionMap[(obj, attr)] = []
				versionMap[(obj, attr)].append(v)

		return v

	def restart(req):
		originalReq = requests[req.id]
		obj = common.findObject(originalReq, 1)
		coordinatorId = findCoordinator(obj)
		req.order = 1
		send(('READ_REQUEST',req,),to=coordinatorId)

	def checkForConflicts(req):
		obj = common.findObject(req, req.updateIndex)
		item = req.updates
		# note: if obj.attr has not been read or written in this session, then
		# v is the special version with v.rts=0 and v.wts=0.
		v = latestVersionBefore(obj, item['attrName'], req.ts)
		if v.rts > req.ts:
			return True
		return False

	def findCoordinator(obj):
		numCoordinators = int(configHashMap['numCoordinators'])
		index = int(obj)%numCoordinators
		return coIdMap[index]
	
	def getWorker():
		numWorkers = int(configHashMap['numWorkers'])
		workerList = workerResCoMap[self.id]
		index = self.workerIndex % numWorkers
		self.workerIndex+=1
		if(workerIndex>=numWorkers):
			workerIndex=0
		return workerList[index]

	def receive(msg=('READ_REQUEST',req), from_=recvProcId):
		output("Received read req from client")
		requests[req.id] = copy.deepcopy(req)
		order = req.order
		obj = common.findObject(req, order)

		if(order == 1):
			req.ts = time.time()

		for attr in common.defReadAttr(obj, req):
			v = latestVersionBefore(obj, attr, req.ts)
			v.rts = req.ts

		for attr in common.mightReadAttr(obj, req):
			v = latestVersionBefore(obj, attr, req.ts)
			v.pendingMightRead.append(req.id)

		req.cachedUpdates[order] = getCachedUpdates(obj,req)

		if(order == 1):
			obj = common.findObject(req, 2)
			coordinatorId = findCoordinator(obj)
			req.order = 2
			send(('READ_REQUEST',req,),to=coordinatorId)
		else:
			workerId = getWorker()
			send(('READ_REQUEST',req,),to=workerId)

	def receive(msg=('WRITE_REQUEST',req), from_=recvProcId):
		output("Received write req from client")
		requests[req.id] = copy.deepcopy(req)
		order = req.order
		obj = common.findObject(req, order)

		if(order == 1):
			req.ts = time.time()

		for attr in common.defReadAttr(obj, req) + common.mightReadAttr(obj, req):
			v = latestVersionBefore(obj, attr, req.ts)
			v.pendingMightRead.append(req.id)

		req.cachedUpdates[order] = getCachedUpdates(obj,req)

		if(order == 1):
			obj = common.findObject(req, 2)
			coordinatorId = findCoordinator(obj)
			req.order = 2
			send(('WRITE_REQUEST',req,),to=coordinatorId)
		else:
			workerId = getWorker()
			send(('WRITE_REQUEST',req,),to=workerId)

	def receive(msg=('RESULT_RDONLY',req), from_=recvProcId):
		output("Received RESULT_RDONLY from Worker")
		obj = common.findObject(req, req.order)
		for attr in common.mightReadAttr(obj, req):
			v = latestVersionBefore(obj, attr, req.ts)
			if req.id in v.pendingMightRead:
				v.pendingMightRead.remove(req.id)
			if attr in req.readAttr[req.order - 1]:
				v.rts = req.ts

	def receive(msg=('RESULT_UPDATE',req), from_=recvProcId):
		output("Received RESULT_UPDATE from Worker")
		obj = common.findObject(req, req.updateIndex)
		conflict = checkForConflicts(req)

		if not conflict:
			item = req.updates
			await(not latestVersionBefore(obj,item['attrName'],req.ts).pendingMightRead or latestVersionBefore(obj,item['attrName'],req.ts).pendingMightRead.count(req.id) == 1)

			conflict = checkForConflicts(req)

			if not conflict:
				item = req.updates
				update = {}
				update['attrName'] = item['attrName']
				update['attrValue'] = item['attrValue']
				if obj in cachedUpdates:
					cachedUpdates[obj].append(update)
				else:
					cachedUpdates[obj] = []
					cachedUpdates[obj].append(update)
				newVersion = Version(0,0)
				newVersion.wts = req.ts
				if (obj, update['attrName']) in versionMap:
					versionMap[(obj,update['attrName'])].append(newVersion)
				else:
					versionMap[(obj,update['attrName'])] = []
					versionMap[(obj,update['attrName'])].append(newVersion)

				for attr in common.defReadAttr(obj,req) + common.mightReadAttr(obj,req):
					v = latestVersionBefore(obj,attr,req.ts)
					if req.id in v.pendingMightRead:
						v.pendingMightRead.remove(req.id)
					if attr in req.readAttr[req.updateIndex - 1]:
						v.rts = req.ts

				send(("RESULT_UPDATE",req,),to=req.clientId)
				obj = common.findObject(req, req.rdOnlyIndex)
				coordinatorId = findCoordinator(obj)
				send(("RESULT_RDONLY",req,),to=coordinatorId)
			else:
				restart(req)
		else:
			restart(req)

