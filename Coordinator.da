common = import_da('common')
common = import_da('Client')
dbEmulator = import_da('DbEmulator')
import logging

import time
import uuid
import copy
import pprint

#stores all original requests indexed by unique id
requests = {}
versionMap = {}
cachedUpdates = {}

#possible status of tentative updates
ongoing = 1
success = 2
failure = 3

class Version():
	def __init__(self,rts,wts):
		self.rts = rts
		self.wts = wts
		self.pendingMightRead = []

class Coordinator(process):
	def setup(configFile:str,coIdMap:dict,dbId:dbEmulator.DbEmulator):
		self.configHashMap={}

	def run():
		#output("hello SubCo!")
		self.configHashMap = common.readConfigFile(configFile)
		output("Hello Im coordinator!!!")
		await(False)

	def cachedUpdates(obj,req):
		cache = {}
		readAttr = defReadAttr(obj,req) union mightReadAttr(obj,req)
		updates = cachedUpdates[obj]
		for item in updates:
			if item.attr in readAttr:
				cache[item.attr] = item.value
		return cache

	def latestVersionBefore(obj, attr, ts):
		versionList = versionMap[(obj, attr)]
		#sort version list based on timestamp
		sortedVersionList = sorted(versionList, key=lambda x: x.wts, reverse=True)
		prev = None
		for v in sortedVersionList:
			if(v.wts > ts):
				break
			prev = v
		
		v = prev
		if(not v):
			v = Version(0, 0)
		return v

	def restart(req):
		originalReq = requests[req.id]
		obj = findObject(originalReq, 1)
		coordinatorId = findCoordinator(obj)
		req.order = 1
		send(('READ_REQUEST',req,),to=coordinatorId)

	def checkForConflicts(req):
		obj = findObject(req, req.updateIndex)
		for item in req.updates:
			# note: if obj.attr has not been read or written in this session, then
			# v is the special version with v.rts=0 and v.wts=0.
			v = latestVersionBefore(obj, item.attr, req.ts)
			if v.rts > req.ts:
				return True
		return False
	
	def receive(msg=('READ_REQUEST',req), from_=recvProcId):
		output("Received read msg from client")
		requests[req.id] = copy.deepcopy(req)
		order = req.order
		obj = findObject(req, order)

		if(order == 1):
			req.ts = time.time()

		for attr in defReadAttr(obj, req):
			latestVersionBefore(obj, attr, req.ts).rts = req.ts

		for attr in mightReadAttr(obj, req):
			latestVersionBefore(obj, attr, req.ts).pendingMightRead.append(req.id)

		req.cachedUpdates[order] = cachedUpdates(obj,req)

		if(order == 1):
			obj = findObject(req, 2)
			coordinatorId = findCoordinator(obj)
			req.order = 2
			send(('READ_REQUEST',req,),to=coordinatorId)
		else
			workerId = getWorker(obj)
			send(('READ_REQUEST',req,),to=workerId)

	def receive(msg=('WRITE_REQUEST',req), from_=recvProcId):
		output("Received write req msg from client")
		output("Received read msg from client")
		requests[req.id] = copy.deepcopy(req)
		order = req.order
		obj = findObject(req, order)

		if(order == 1):
			req.ts = time.time()

		for attr in defReadAttr(obj, req) + mightReadAttr(obj, req):
			v = latestVersionBefore(obj, attr, req.ts)
			v.pendingMightRead.add(req.id)

		req.cachedUpdates[order] = cachedUpdates(obj,req)

		if(order == 1):
			obj = findObject(req, 2)
			coordinatorId = findCoordinator(obj)
			req.order = 2
			send(('WRITE_REQUEST',req,),to=coordinatorId)
		else
			workerId = getWorker(obj)
			send(('WRITE_REQUEST',req,),to=workerId)